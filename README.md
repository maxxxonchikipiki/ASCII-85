# ASCII85

При передаче бинарных данных по существующим протоколам, предназначенным исключительно для передачи текста (например, почтновые протоколы), возникает потребность в кодировании данных текстом. 
Многие протоколы для передачи текста могут гарантированно передавать только 7-битные значения (и при этом нужно избегать использования управляющих символов ASCII), а также могут требовать вставки символа конца строки для ограничения длины строк, к тому же допускают пробельные отступы. 
В итоге остается только 94 печатных символа, которые можно использовать.

Ascii85 (Base85) — это форма кодирования двоичных данных при помощи текста, в которой для кодирования 4 байт данных используется 5 ASCII символов. В результате достигается большая эффективность, чем в случае Base64, в которой каждые 3 байта кодируются 4 символами.

Применяется в форматах файлов PostScript (.ps) и Portable Document Format (.pdf), а также при кодировании бинарных файлов в Git.

4 байта могут содержать 2<sup>32</sup> = 4'294'967'296 различных значений. 5 цифр в системе счисления с основанием 85 дают 85<sup>5</sup> = 4'437'053'125 различных значения, чего вполне достаточно для однозначного представления 32-битных значений. 
Пять цифр в системе счисления с основанием 84 могут предоставить только 84<sup>5</sup> = 4'182'119'424 значений. 
Следовательно, 85 является минимальным основанием системы счисления, в которой 4 байта можно закодировать пятью цифрами.

При кодировании:
1. Разделяем поток данных на группы по 4 байта и рассматриваем каждую из них как 32-битное число, со старшим байтом в начале. 
2. Последовательным делением на 85 получаем 5 цифр 85-ричной системы счисления. 
3. Далее каждую цифру кодируем печатным символом ASCII, путём увеличения на 33 (то есть символами с кодами от 33 до 117), и выводим в выходной поток с сохранением порядка от старшего разряда к младшему.

Поскольку нулевые значения встречаются не так уж и редко, то ради дополнительного сжатия сделано дополнительное исключение — нулевая четверка байтов кодируется единственным символом `z` вместо `!!!!!`.

В начало закодированной последовательности добавляется разделитель `<~`.

Так как в исходном сообщении число байт может быть не кратно 4, то для обозначения конца закодированной строки и определения, где нужно обрезать раскодированную строку для получения верной длины, в конце закодированного сообщения добавляется разделитель `~>`.
Делается это так: если последний блок содержит меньше 4 байтов, то он перед кодированием дополняется нулевыми байтами, а после кодирования из последней пятерки убирается столько крайних символов, сколько нулей было добавлено.
При декодировании последний блок дополняется до длины 5 символом `u` (код 84 в таблице ASCII85), а после раскодирования столько же байт удаляется.

В блоке текста Ascii85 в любом месте могут быть вставлены пробельные символы и переносы строк, в том числе и внутри пятерок букв. Они должны просто игнорироваться.

Необходимо написать программу, которая осуществляет кодирование исходного сообщения в ASCII85 и декодирование сообщения из ASCII85.

Выполняемое действие, имена входного и выходного файлов задаются в командной строке. 

Например, для кодирования файла `input.txt` и записи ответа в файл `output.a85`:
```
   ./ascii85 -e input.txt output.a85
```
Для декодирования файла `input.a85` и записи ответа в файл `output.txt`:
```
   ./ascii85 -d input.a85 output.txt
```

## Формат выходного файла
Закодированный текст разбить на строки длиной 75 символов. Последняя строка не длиннее 75 символов.

## Требования
Программа не должна использовать контейнеры STL (std::vector, std::string и т. д.). 
